= Spring Cloud
:toc: left
:imagesdir: images

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

In this tutorial you will focus on developing an application that will run in an environment using an assorted set of microservices patterns. The main purpose is to highlight how Spring Cloud helps in such an environment, to get an understanding of how it all works.

The tutorial is purposely designed to hold your hand and show you step by step what to do. The main goal is not to challenge your problem solving skills, instead we want to focus on presenting Spring Cloud concepts in small chunks, eventually leading up to a working application.

With that said, donâ€™t blindly just copy and paste the code without reflecting on it. The tutorial will try to make you think about things here and there, but if you find any step confusing or lacking in description, please bring it up during the session so we can discuss it.

== Overview of the application components
image::schematic-overview.png[]

We are going to build a set of Java https://spring.io/projects/spring-boot[Spring Boot] components using https://spring.io/projects/spring-cloud[Spring Cloud] tools. Some of these components will implement common microservices patterns used in distributed systems, these are hence of a more supportive nature.

Config Server:: The Config server's responsibility is to be the central for configuration of all other components.

Gateway:: The Gateway is the single point entrance to the outside world. Clients from the outside must go through the Gateway to access the inner services. A key role of the Gateway is to route incoming requests to the right service.

Service Discovery and Client Loadbalancer:: All services in the application will register to Service Discovery server. This allow Spring Cloud components to automatically find each other. The Client Load Balancer will help in evenly distributing requests to multiple running instances of the same microservice.

Along with the above we also need microservices that takes the role as our business components, the ones serving data that clients are interested in.

Items Service:: This service is responsible for handling _items_. It stores items and can retrieve information about items on demand.

Reviews Service:: Manages customer _reviews_ regarding _items_. It stores reviews and can retrieve information about reviews on demand.

Web API:: Acts as an aggregating API, it knows what services to call in order to aggregate certain information (in our case from _items service_ and _reviews service_).



We will explain more about each component when we start working on them, but before getting started with that, there is something to be said about _Maven_ and also _Spring Initializr_

== Maven
Maven is a build and dependency management tool widely used in the Java echo system.

[NOTE]
If you have been working with Java you can stop reading now, we are not going to say anything new on the matter. But please read on if you are not so familiar with Maven since it may save one or two WTF:s along the way.

At the core of a https://maven.apache.org/[Maven] project is the `pom.xml` file (stands for Project Object Model), which is an XML-representation of how the project is setup. In here you specify what should be built in the project, and all project dependencies to other components (internal or third-party) are declared here.

The projects we are going to build will have dependencies to several Spring Cloud components.

A Maven project is built by executing the command `mvn clean install`, which will automatically download all dependencies specified (and all dependencies these first dependencies in turn may require). This can take a while, like a minute or two. The download will only happen if any dependencies are missing on your computer, so the next time you build, the console output will not be quite so busy as the first time.

The downloaded dependencies are typically stored under a directory named `.m2` in your user directory.

== Spring Initializr

Spring Boot provides a tool for quickly setting up a base Maven project with dependencies to various Spring components, which can be searched for and added to project in a wizard-like manner. https://start.spring.io/[Spring Initializr] basically creates a `pom.xml` file for you with everything needed for running the selected components.

image::initializr.png[]

You will use this tool when creating the components in this tutorial.

Which we incidentally will be start doing right now. Let's begin with the first service, the _Items Service_.

== Items Service
asdasd

=== Creating the project

[quote]
____
. Go to https://start.spring.io/
. Enter the following values in fields:
.. `Group:` com.acorn.tutorial
.. `Artifact:` items-service
. Add dependencies (search for them and select):
.. Spring Data JPA
.. Spring Web
.. Lombok
.. Spring Boot Actuator
.. H2 Database
. Click `Generate the project`
. Open the resulting zip and copy the items-service directory to the root of the project (acorn-microservices-tutorial)
____

Alternative way using IntelliJ:
[quote]
____
. Right-click acorn-microservices-tutorial in the Project pane, select `New -> Module...`
. Select `Spring Initializr`
. In the Project Metadata dialog, enter the following fields:
.. `Group:` com.acorn.tutorial
.. `Artifact:` items-service
. Click `Next`
. Add dependencies (search for them and select):
.. Spring Data JPA
.. Spring Web
.. Lombok
.. Spring Boot Actuator
.. H2 Database
. Click `Next`
. Click `Finish`

____

Now we need to make the copied project into a child-project of the intitial maven project, this means that it is time for edit a couple of pom.xml files.

First of all, edit the newly created child pom.xml to point to the parent pom file:
[quote]
____
. Open `acorn-microservices-tutorial/items-service/pom.xml`
. Change the reference to parent pom as follows:
+
Change
+
[source,xml]
----
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.1.8.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.acorn.tutorial</groupId>
    <artifactId>items-service</artifactId>
    <version>0.0.1-SNAPSHOT</version>

----
to
+
[source,xml]
----
    <parent>
        <groupId>com.acorn.tutorial</groupId>
        <artifactId>acorn-microservices-tutorial</artifactId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <artifactId>items-service</artifactId>

----
+
Note that _groupId_ and _version_ attributes of items-service can be removed since this project now inherits these attributes from the parent pom.
____

Next edit the parent pom.xml so that it becomes aware of the child project:
[quote]
____
. Open `acorn-microservices-tutorial/items-service/pom.xml`
. Add `items-service` as module in the parent pom:
+
Change
+
[source,xml]
----
    <properties>
        <java.version>8</java.version>
        <spring-cloud.version>Greenwich.SR2</spring-cloud.version>
    </properties>

    <dependencyManagement>
        ...
    </dependencyManagement>
----
to
+
[source,xml]
----
    <properties>
        <java.version>8</java.version>
        <spring-cloud.version>Greenwich.SR2</spring-cloud.version>
    </properties>

    <modules>
        <module>items-service</module>
    </modules>

    <dependencyManagement>
        ...
    </dependencyManagement>
----
____

Let's remove some autogenerated files we don't need, delete the following files from project:

- items-service/.mvn (the whole dir)
- items-service/.gitignore
- items-service/HELP.md
- items-service/mvnw
- items-service/mvnw.cmd

Very good. We are now in a position where we should be able to build the Maven project successfully. Do this by running the command
[source, bahs]
mvn clean install -DskipTests

Note that you must run the command with the flag `-DskipTests`, if not an autogenerated Spring test will fail.

Expected outcome after running the command:

[source]
----
[INFO] Reactor Summary:
[INFO]
[INFO] acorn-microservices-tutorial ....................... SUCCESS [  0.745 s]
[INFO] items-service ...................................... SUCCESS [  2.767 s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------

----

=== Running the application
Ok, the Maven project is now setup and the application has been successfully built. It is actually possible to run it already, even though we haven't added anything that resembles Java code yet.

Run the app by using one of these two options.

Run from IDE:: Both IntelliJ and Eclipse can execute Spring Boot applications, which is the most convenient approach and recommended hereafter.
+
IntelliJ: There should be a Run configuration named `ItemsServiceApplication` already created, available near the top right corner of the IDE. Press the green play-button to start the application. This will build and run the app.
+
Eclipse: TODO

Run from command line:: It is also possible to execute it directly from a command prompt if you fancy:
+
[source, bash]
----
cd acorn-microservices-tutorial/items-service/target

java -jar items-service-1.0-SNAPSHOT.jar
----

The application is up and running successfully if the console output is quite serene (no wild exception or error logs flying around) and if you see this as the last log entry:

[source, bash]
----
2019-09-09 18:53:13.394  INFO 11412 --- [           main] c.a.t.i.ItemsServiceApplication          : Started ItemsServiceApplication in 2.745 seconds (JVM running for 3.475)
----

It also possible to check the health status of the app by accessing http://localhost:8080/actuator/health, which should result in rather dry but informative JSON-message.

[source, json]
----
{
"status": "UP"
}
----

[NOTE]
====
Your keen eyes have already noticed some things that perhaps raise questions. Like that the application has been started with a Tomcat running on port 8080, that a JPA EntityManagerFactory has been initialized, and that Hibnernate seems to be configured using the dialect org.hibernate.dialect.H2Dialect.

What does all this come from, and why port 8080?

The short answer is: Spring Boot relies heavily on the concept of convention over configuration. We did add a set of Maven dependencies that brings in JPA, Hibernate and H2 (in-memory) DB to the classpath. We didn't configure any of them, so Spring Boot starts them using _sensible_ default values. Port 8080 is also the default value used for Tomcat if nothing else is specified.

This behavior can give Spring Boot an aura of _automagic_, things work even if you don't know why. This is something you may both love and hate (the latter when things go wrong), but it is convenient for quickly spinning up things. It is of course possible to define our own config, as we will do now.

====

=== Configuring the Item Service application

Rename application.properties to application.yml and add config
[source,yml]
----
spring:
  application:
    name: items-service

  # Enabling h2 console, accessible at http://localhost:8080/h2-console
  # (use JDBC URL: jdbc:h2:mem:testdb, user: sa, password: empty (leave blank))
  h2:
    console:
      enabled: true
  jpa:
    show-sql: false
    properties:
      hibernate:
        format_sql: true
        generate_statistics: false

logging:
  file: /tmp/codingsession/logs/items-service.log
  level:
    ROOT: INFO
    org.hibernate.stat: INFO
    org.hibernate.type: INFO

server:
  port: 8080
----

=== Adding source code

== Config Server
