= Spring Cloud
:toc: left
:imagesdir: images

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

In this tutorial you will focus on developing an application that will run in an environment using an assorted set of microservices patterns. The main purpose is to highlight how Spring Cloud helps in such an environment, to get an understanding of how it all works.

The tutorial is purposely designed to hold your hand and show you step by step what to do. The main goal is not to challenge your problem solving skills, instead we want to focus on presenting Spring Cloud concepts in small chunks, eventually leading up to a working application.

With that said, donâ€™t blindly just copy and paste the code without reflecting on it. The tutorial will try to make you think about things here and there, but if you find any step confusing or lacking in description, please bring it up during the session so we can discuss it.

== Overview of the application components
We are going to build a set of Java https://spring.io/projects/spring-boot[Spring Boot] components using https://spring.io/projects/spring-cloud[Spring Cloud] tools. Some of these components will implement common microservices patterns used in distributed systems, such as centralized configuration and service discovery, and are hence of a more supportive nature:

Supporting components::
* Config Server
* Gateway
* Service Discovery and Client Loadbalancer

Along with the above we also need microservices that takes the role as our business components, the ones serving data that clients are interested in:

Business components::
* Web API
* Items Service

image::schematic-overview.png[]

We will explain more about each component when we start working on them, but before getting started there is something to be said about _Maven_ and also _Spring Initializr_

== Maven
Maven is a build and dependency management tool widely used in the Java echo system.

[NOTE]
If you have been working with Java you can stop reading now, we are not going to say anything new on the matter. But please read on if you are not so familiar with Maven since it may save one or two WTF:s along the way.

At the core of a https://maven.apache.org/[Maven] project is the `pom.xml` file (stands for Project Object Model), which is an XML-representation of how the project is setup. In here you specify what should be built in the project, and all project dependencies to other components (internal or third-party) is declared here.

In the projects we are going to build there will be several dependencies to Spring Cloud components.

A Maven project is built by executing the command `mvn clean install`, which will automatically download all dependencies specified (and all dependencies these first dependencies in turn may require). This can take a while, like a minute or two. The download will only happen if any dependencies are missing on your computer, so the next time you build, the console output will not be quite so busy as the first time.

The downloaded dependencies are typically stored under a directory named `.m2` in your user directory.

== Spring Initializr

Spring Boot provides a tool for quickly setting up a base Maven project with dependencies to various Spring components, which can be searched for and added to project in a wizard-like manner. https://start.spring.io/[Spring Initializr] basically creates a `pom.xml` file for you with everything needed for running the selected components.

image::initializr.png[]

You will use this tool when creating the components in this tutorial, which we incidentally will be start doing right now. Let's begin with the first service, the Items Service.

== Items Service
asdasd

=== Creating the project

[quote]
____
. Go to https://start.spring.io/
. Enter the following values in fields:
.. `Group:` com.acorn.tutorial
.. `Artifact:` items-service
. Add dependencies (search for them and select):
.. Spring Data JPA
.. Spring Web
.. Lombok
.. Spring Boot Actuator
.. H2 Database
. Click `Generate the project`
. Open the resulting zip and copy the items-service directory to the root of the project (acorn-microservices-tutorial)
____

Alternative way using IntelliJ:
[quote]
____
. Right-click acorn-microservices-tutorial in the Project pane, select `New -> Module...`
. Select `Spring Initializr`
. In the Project Metadata dialog, enter the following fields:
.. `Group:` com.acorn.tutorial
.. `Artifact:` items-service
. Click `Next`
. Add dependencies (search for them and select):
.. Spring Data JPA
.. Spring Web
.. Lombok
.. Spring Boot Actuator
.. H2 Database
. Click `Next`
. Click `Finish`
____

Now we need to make the copied project into a child-project of the intitial maven project, this means that it is time for edit a couple of pom.xml files.

First of all, edit the newly created child pom.xml to point to the parent pom file:
[quote]
____
. Open `acorn-microservices-tutorial/items-service/pom.xml`
. Change the reference to parent pom as follows:
+
Change
+
[source,xml]
----
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.1.8.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.acorn.tutorial</groupId>
    <artifactId>items-service</artifactId>
    <version>0.0.1-SNAPSHOT</version>

----
to
+
[source,xml]
----
    <parent>
        <groupId>com.acorn.tutorial</groupId>
        <artifactId>acorn-microservices-tutorial</artifactId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <artifactId>items-service</artifactId>

----
+
Note that _groupId_ and _version_ attributes of items-service can be removed since this project now inherits these attributes from the parent pom.
____

Next edit the parent pom.xml so that it becomes aware of the child project:
[quote]
____
. Open `acorn-microservices-tutorial/items-service/pom.xml`
. Add `items-service` as module in the parent pom:
+
Change
+
[source,xml]
----
    <properties>
        <java.version>8</java.version>
        <spring-cloud.version>Greenwich.SR2</spring-cloud.version>
    </properties>

    <dependencyManagement>
        ...
    </dependencyManagement>
----
to
+
[source,xml]
----
    <properties>
        <java.version>8</java.version>
        <spring-cloud.version>Greenwich.SR2</spring-cloud.version>
    </properties>

    <modules>
        <module>items-service</module>
    </modules>

    <dependencyManagement>
        ...
    </dependencyManagement>
----
____

Let's remove some autogenerated files we don't need, delete the following files from project:

- items-service/.mvn (the whole dir)
- items-service/.gitignore
- items-service/HELP.md
- items-service/mvnw
- items-service/mvnw.cmd

Very good. We are now in a position where we should be able to build the Maven project successfully. Do this by running the command
[source, bash]
mvn clean install -DskipTests

Note that you must run the command with the flag `-DskipTests`, if not an autogenerated Spring test will fail.

Expected outcome after running the command:

[source]
----
[INFO] Reactor Summary:
[INFO]
[INFO] acorn-microservices-tutorial ....................... SUCCESS [  0.745 s]
[INFO] items-service ...................................... SUCCESS [  2.767 s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------

----

=== Running the application
Ok, the Maven project is now setup and the application has been successfully built. It is actually possible to run it already, even though we haven't added anything that resembles Java code yet.

Run the app by using one of these two options.

Run from IDE:: Both IntelliJ and Eclipse can execute Spring Boot applications, which is the most convenient approach and recommended hereafter.
+
IntelliJ: There should be a Run configuration named `ItemsServiceApplication` already created, available near the top right corner of the IDE. Press the green play-button to start the application. This will build and run the app.
+
Eclipse: TODO

Run from command line:: It is also possible to execute it directly from a command prompt if you fancy:
+
[source, bash]
----
cd acorn-microservices-tutorial/items-service/target

java -jar items-service-1.0-SNAPSHOT.jar
----

The application is up and running successfully if the console output is quite serene (no wild exception or error logs flying around) and if you see this as the last log entry:

[source, bash]
----
2019-09-09 18:53:13.394  INFO 11412 --- [           main] c.a.t.i.ItemsServiceApplication          : Started ItemsServiceApplication in 2.745 seconds (JVM running for 3.475)
----

It also possible to check the health status of the app by accessing http://localhost:8080/actuator/health, which should result in a rather dry but informative JSON-message.

[source, json]
----
{
"status": "UP"
}
----

[NOTE]
====
If you have been glancing the log output, your keen eyes have probably noticed some things that perhaps raises questions. Like the application has been started with a Tomcat running on port 8080, that a JPA EntityManagerFactory has been initialized, and Hibnernate seems to be configured using the dialect org.hibernate.dialect.H2Dialect.

What does all this come from, and why port 8080?

The short answer is: Spring Boot relies heavily on the concept of convention over configuration. We did add a set of Maven dependencies that brings in JPA, Hibernate and H2 (in-memory) DB to the classpath. We didn't configure any of them, so Spring Boot starts them using _sensible_ default values. Port 8080 is also the default value used for Tomcat if nothing else is specified.

This behavior can give Spring Boot an aura of _automagic_, things work even if you don't know why. This is something you may both love and hate (the latter when things go wrong), but it is convenient for quickly spinning up things. It is of course possible to define our own config, as we will do now.
====

=== Configuring the Item Service application

We need to add some configuration to the project, which is typically done in `src/main/resources/application.properties`.

[NOTE]
For now we will add the configuration locally in the project. Later on in the tutorial we will start centralize the configuration and put it into the Config Server instead.

The file `application.properties` is an ordinary properties file as they usually come in the Java echo system, properties are declared in the normal _key=value_ fashion.

Spring also supports files written in yaml-format, which has the benefit of showing the properties more orderly. In this tutorial we will go with yaml-files.

So in order to add the props we want, rename `application.properties` to `application.yml` and add this config to the file:
[source,yml]
----
# This is the name of the application, will later be needed since it will be used by other components in Spring Cloud to identify the application.
spring:
  application:
    name: items-service

  # Enabling h2 console, accessible at http://localhost:8080/h2-console
  # (use JDBC URL: jdbc:h2:mem:testdb, user: sa, password: empty (leave blank))
  h2:
    console:
      enabled: true
  jpa:
    show-sql: false
    properties:
      hibernate:
        format_sql: true
        generate_statistics: false

logging:
  file: /tmp/codingsession/logs/items-service.log
  level:
    ROOT: INFO
    org.hibernate.stat: INFO
    org.hibernate.type: INFO

# The server port to use on startup. This is incidentally the same as the default 8080, but is shown for clarity. If you change the port to any other value, this will be used instead (please go ahead and try if you don't believe us saying so)
server:
  port: 8080
----

=== Adding source code

It is high time to cut the crap and start adding some proper code. We must implement the features needed for serving _Items_.

This is what we should add:

* A model class that will define how an Item object will look like. This will also take the role of an JPA-entity so it can be stored in database.
* A Spring-JPA repository class that will handle the persistence of Item objects.
* A Spring RestController class that will act as the REST-API to the outside, which will provide resources for retrieving _Item_ objects and present them on JSON-format
* A DTO (data transfer object) that represents the JSON reponse

==== Model class
asdasd

[quote]
____
. Create a new package under `items-service/src/main/java/com/acorn/tutorial/itemsservice`, name it `model`
. Add a file named `Items.java` with the below content:
+
[source,java]
----
@Data
@NoArgsConstructor
@Entity
public class Item {

    @Id
    @GeneratedValue(strategy=GenerationType.AUTO)
    private Long id;

    private String name;
}
----
+
Here is a short description of the annotations if you are not familiar with all of them.
+
|===
|Annotation |Description

|@Data
|Lombok-annotation, does generate getters/setters, toString, equals, hashcode, and a required args constructor

|@NoArgsConstructor
|Lombok-annotation, creates a no arguments constructor, which is needed by JPA.

|@Entity
|JPA-annotation, represents a POJO that can be persisted to database.

|@Id
|JPA-annotation, basically defines the identity of the entity, which will become the primary key in database.

|@GeneratedValue
|JPA-annotation, tells which strategy to use when generating identifier values. _GenerationType.AUTO_ means that we delegate to the JPA-provider (in our case Hibernate) to decide which strategy to use.
|===
____

==== Repository class
Next up is to add the class that will make storing items in database possible.
[quote]
____
. Create a new package under `items-service/src/main/java/com/acorn/tutorial/itemsservice`, name it `repository`
. Add a file named `ItemRepository.java` with the below content:
+
[source,java]
----
@Repository
public interface ItemRepository extends JpaRepository<Item, Long> {

}
----
____

This is actually enough code for making Spring Data JPA setup the database for handling _Item_ objects. The Spring automagic kicks in here. Just the simple act of having the dependencies `org.springframework.boot:spring-boot-starter-data-jpa` and `com.h2database:h2` brought in to the project's classpath, will allow Spring Data JPA to read our entity class and setup the database with needed tables etc.

You can check this for yourself by starting the application, then browse to http://localhost:8080/h2-console, use JDBC URL: jdbc:h2:mem:testdb and log in using User _sa_ and no password:

image::H2Console.png[]

Once logged in you should be able to see a listing of database tables and more.

[TIP]
This is not a tutorial in using Spring Data JPA so we will leave it without deeper explanation, but for those interested in details, please see https://dzone.com/articles/spring-data-jpa-1 or visit the official reference at https://docs.spring.io/spring-data/jpa/docs/current/reference/html/

One final automagical thing before leaving the persistence area for this time. I would be nice if we could have some dummy data loaded into the system. This can be achieved simply adding a file named `src/main/resources/data.sql` and add a couple of INSERT statements into it:

[quote]
____
. Create the file `items-service/src/main/resource/data.sql`
. Add some items:
+
[source,sql]
----
insert into item(id, name) values(1, 'Spoon');
insert into item(id, name) values(2, 'Fork');
insert into item(id, name) values(3, 'Knife');
----
____

That's it. Restart the application, log in to http://localhost:8080/h2-console again and run

[source,sql]
SELECT * FROM ITEM

Now you should see what you think you should see. ;)

So now we do have a database storing _Item_ objects, and the application is connected to it. Spring Data JPA will give us a set of pre-existing methods for  getting data from the database. We will start to use these in the next section.

==== RestController class
The purpose of this class is to provide a REST-API to the surrounding microservices environment.

[quote]
____
. Create a new package under `items-service/src/main/java/com/acorn/tutorial/itemsservice`, name it `web`
. Add a file named `ItemServiceController.java` with the below content:
+
[source,java]
----
@RestController
public class ItemsServiceController {

    private static final Logger LOGGER = LoggerFactory.getLogger(ItemsServiceController.class);

    private ItemRepository itemRepository;

    private Environment environment;

    @Autowired
    public ItemsServiceController(ItemRepository itemRepository, Environment environment) {
        this.itemRepository = itemRepository;
        this.environment = environment;
    }

    @GetMapping(path = "/items", produces = "application/json")
    public List<ItemDto> getAllItems() {
        return itemRepository.findAll()
                .stream()
                .map(this::toItemDto)
                .collect(Collectors.toList());
    }

    @GetMapping(path = "/items/{id}", produces = "application/json")
    public ItemDto getItem(@PathVariable Long id) {
        Item item = itemRepository.findById(id)
                .orElseThrow(() -> new ItemNotFoundException(id));

        return toItemDto(item);
    }

    private ItemDto toItemDto(Item item) {
        int port = Integer.parseInt(environment.getProperty("local.server.port", "0"));
        final ItemDto itemDto = ItemDto.of(item, port);
        LOGGER.info(String.format("Returning %s", itemDto));
        return itemDto;
    }
}
----
____

The above code creates a Spring REST controller providing the resources `GET /items` and `GET /items/{id}`. The previously created `Item` and `ItemRepository` classes are used here. Pay close attention to the `itemRepository.findAll()` and `itemRepository.findById(id)` methods, which are provided ot us through Spring Data JPA.

Right now the code does not compile, a couple of classes are still missing so let's create them also.

==== ItemDto
This is just a POJO that represents the JSON structure to send out from REST API.

[source,java]
----
@Data
@AllArgsConstructor
public class ItemDto {

    private Long id;
    private String name;
    private int port;

    public static ItemDto of(Item item, int port) {
        return new ItemDto(item.getId(), item.getName(), port);
    }
}
----

== Config Server
