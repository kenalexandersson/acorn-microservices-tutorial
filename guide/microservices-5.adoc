= Spring Cloud
:toc: left
:imagesdir: images

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

== WebApi
The webapi will be responsible for aggregating data and information from underlying services, and deliver it in a format suitable for the client.

As you recall from the previous section, the webapi is influenced by the Backends for Frontends (BFF) pattern.

image::bff.png[]

Translated to our schematic overview, _WebApi_ takes the same role as _Web BFF_ or _Mobile BFF_ do in figure 1 above.

image::overview-5-webapi.png[]

The `webapi` component will provide a set of REST resources for retrieving _items_ and _reviews_ from `items-service` and `reviews-service`. It will make use of the `service-discovery-client` to find where these services are located.

[TIP]
====
What does a BFF typically do apart from aggregating stuff for it's best friend client?
Can handle api-keys and authentication if desired.
====

=== Creating the project

[quote]
____
. Go to https://start.spring.io/ (or use IntelliJ `New -> Module... -> Spring Initializr`)
. Enter the following values in fields:
.. `Group:` com.acorn.tutorial
.. `Artifact:` webapi
. Add dependencies (search for them and select):
.. Config Client
.. Spring Web
.. Spring Boot Actuator
.. Lombok
. Click `Generate the project`
. If using https://start.spring.io: open the resulting zip and copy the items-service directory to the root of the project (acorn-microservices-tutorial)
____

[TIP]
====
Let's remove some autogenerated files we don't need, delete the following files from project:

- webapi/.mvn (the whole dir)
- webapi/.gitignore
- webapi/HELP.md
- webapi/mvnw
- webapi/mvnw.cmd
====

Next edit the parent pom.xml so that it becomes aware of the child project:
[quote]
____
. Open `acorn-microservices-tutorial/pom.xml`
. Add `webapi` to the modules list in the parent pom:
+
[source,xml]
----
    ...

    <modules>
        <module>config-server</module>
        <module>service-discovery-server</module>
        <module>items-service</module>
        <module>reviews-service</module>
        <module>webapi</module>
    </modules>

    ...
----
____

Build the project to verify that all is glued together correctly, and for downloading dependencies:
[source, bash]
----
# Run mvn clean install from the acorn-microservices-tutorial directory
mvn clean install -DskipTests
----

Expected outcome after running the command:

[source]
----
[INFO] Reactor Summary for acorn-microservices-tutorial 0.0.1-SNAPSHOT:
[INFO]
[INFO] config-server ...................................... SUCCESS [  5.067 s]
[INFO] service-discovery-server ........................... SUCCESS [  2.776 s]
[INFO] items-service ...................................... SUCCESS [  4.540 s]
[INFO] reviews-service .................................... SUCCESS [  6.234 s]
[INFO] webapi ............................................. SUCCESS [  5.998 s]
[INFO] acorn-microservices-tutorial ....................... SUCCESS [  0.316 s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
----

=== Configuring the WebApi
The first thing to configure is to hook up the WebApi with the Config Server.

* The application's general config should be defined in the central `config-server`
* A `bootstrap.yml` file must be created, holding the config for binding to the `config-server`

[quote]
____
. Create the file `config-server/src/main/resource/config/webapi.yml`
. Add config to file:
+
[source,yml]
----
eureka:
  client:
    register-with-eureka: true
    service-url:
      default-zone: http://localhost:8761/eureka
----
+
. Rebuild the `config-server`
+
[source,bash]
----
cd config-server
mvn clean install -DskipTests
----
+
. Restart `config-server`
. Verify that all looks good by accessing http://localhost:7777/webapi/default
____

Next create the `webapi/src/main/resources/bootstrap.yml` and add config for binding to `config-server`
[quote]
____
. Delete `webapi/src/main/resources/application.properties`
. Create the file `webapi/src/main/resource/bootstrap.yml`
. Add config to file:
+
[source,yml]
----
spring:
  application:
    name: webapi
  cloud:
    config:
      uri: http://localhost:7777
      fail-fast: true

feign:
  hystrix:
    enabled: false

server:
  port: 8100
----
____

=== Adding source code
Let's add some initial code that defines the REST API in the form of a `@RestController`. The goal is to have this controller call `items-service` and `reviews-service` and aggregate the information into `ItemInfoDto`, which is sent back in responses.

Start with adding the `ItemInfoDto` class. Noteworthy here is that this class represents an _Item_ with it's associated _Reviews_.

[quote]
____
. Create a new package `webapi/src/main/java/com/acorn/tutorial/webapi/web`
. Add a file named `ItemInfoDto.java` with the below content:
+
[source,java]
----
import java.util.List;
import lombok.ToString;
import lombok.Value;

@ToString
@Value(staticConstructor = "of")
public class ItemInfoDto {

    private Item item;
    private List<Review> reviews;
}
----
+
[NOTE]
The lombok annotation `@Value(staticConstructor = "of")` will create a private constructor and a static factory method named _of_ that allows creation of objects by using `ItemInfoDto.of(item, reviews)`.
+
. Make it compile by adding `Item.java` and `Review.java` as well. These two classes will later be used for mapping responses from `items-service` and `reviews-service`
.. `webapi/src/main/java/com/acorn/tutorial/webapi/web/Item.java`
+
[source,java]
----
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.ToString;

@Data
@ToString
@AllArgsConstructor
public class Item {

    private Long id;

    private String name;

    private int port;
}
----
.. `webapi/src/main/java/com/acorn/tutorial/webapi/web/Review.java`
+
[source,java]
----
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.ToString;

@Data
@AllArgsConstructor
@ToString
public class Review {

    private Long id;

    private String type;

    private Long typeId;

    private Integer rating;

    private Integer ratingMin;

    private Integer ratingMax;

    private String comment;

    private int port;
}
----
____

Now we can concentrate on the actual REST endpoints, by adding a class `WebApiController.java` that uses the annotation `@RestController`.

[quote]
____
. Add `webapi/src/main/java/com/acorn/tutorial/webapi/web/WebApiController.java`. In the beginning this will only contain skeleton code, just returning empty objects.
+
[source,java]
----
import java.util.Collections;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class WebApiController {

    private static final Logger LOGGER = LoggerFactory.getLogger(WebApiController.class);

    @GetMapping(path = "/webapi/items")
    public List<ItemInfoDto > getItems() {
        LOGGER.info("/webapi/items called");

        return Collections.singletonList(ItemInfoDto.of(null, null));
    }

    @GetMapping(path = "/webapi/items/{id}")
    public ItemInfoDto getItem(@PathVariable Long id) {
        LOGGER.info(String.format("/webapi/items/%d called", id));

        return ItemInfoDto.of(null, null);
    }
}
----
____

So far we haven't encountered anything new here, we have used REST-controllers before in `items-service` and `reviews-service`. This is yet another REST-interface, but it is starting to get interesting now since a new question springs to mind:

How do we call the underlying services in the most easiest way?

What we want the `webapi` to do is this:

* Have a convenient way of calling the underlying services' REST-API. For this we will introduce a new Spring Cloud tool called _OpenFeign_.
* Look up where to find the underlying services via the `service-discovery-service`. For this to work we need to make `webapi` into a discovery  service client.

==== Spring Cloud OpenFeign

Spring Cloud OpenFeign is a declarative REST client for Spring Boot applications. Feign makes writing web service clients easier with pluggable annotation support, which includes Feign annotations and JAX-RS annotations.

Also, Spring Cloud adds support for Spring MVC annotations and for using the same HttpMessageConverters as used in Spring Web.

A major benefit with using Feign is that we don't have to write any code for calling the service, other than an interface definition.

https://cloud.spring.io/spring-cloud-openfeign/reference/html/

To start using OpenFeign, we must first add a dependency into the pom.xml file, and also enable it in the application.

[quote]
____
. Open `webapi/pom.xml` and add the below dependency
+
[source,xml]
----
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-openfeign</artifactId>
    </dependency>
----
+
. Enable OpenFeign by opening `webapi/src/main/java/com/acorn/tutorial/webapi/WebapiApplication.java` and adding `@EnableFeignClients`. Note that the base package `com.acorn.tutorial.webapi` is specified as well, meaning that classes under this package can be feign clients.
+
[source,java]
----
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@EnableFeignClients("com.acorn.tutorial.webapi")
@SpringBootApplication
public class WebapiApplication {

    public static void main(String[] args) {
        SpringApplication.run(WebapiApplication.class, args);
    }

}
----
____

The next logical step would be to create the actual clients for `items-service` and `reviews-service`. First in their rawest form, and later a bit more elaborated. Let us start with the _Items client_.

[quote]
____
. Create the file `webapi/src/main/java/com/acorn/tutorial/webapi/web/ItemsClient.java`
+
[source,java]
----
import java.util.List;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(name = "items-service")
public interface ItemsClient {

    @GetMapping("/items")
    List<Item> getItems();

    @GetMapping("/items/{id}")
    Item getItem(@PathVariable Long id);
}
----
+
. Create the file `webapi/src/main/java/com/acorn/tutorial/webapi/web/ReviewsClient.java`
+
[source,java]
----
import java.util.List;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(name = "reviews-service")
public interface ReviewsClient {

    @GetMapping("/reviews/{type}")
    List<Review> getReviews(@PathVariable String type);

    @GetMapping("/reviews/{type}/{typeid}")
    List<Review> getReviews(@PathVariable String type, @PathVariable Long typeid);
}
----
____

Three things are notable here, namely

* The `@FeignClient(name = "items-service")` and `@FeignClient(name = "reviews-service")` annotation values refer to the service name of each service, the one defined in `bootstrap.yml`, for example
+
[source,yml]
----
spring:
  application:
    name: items-service
----
+
This is important because these are the names the services are registered with in the discovery server. Make sure these names match properly.
+
* The interfaces declare methods for retrieving data from `items-service` and `reviews-service` respectively.
* The previously created classes `Item` and `Review` acts as model objects into which responses from services will get mapped.

And yes, that is pretty much what's needed for start calling the underlying services. Unless a couple of things. First, the `webapi` must become a client to the discovery server so the Feign clients can query where to send their REST-calls. After that we should add code that uses the `ItemsClient` and `ReviewsClient` interfaces.

==== Making webapi into a discovery server client
This is very easy. In true Spring Cloud fashion, it is enough to just add the right dependency and put the correct annotation into the application class:
[quote]
____
. Open `webapi/pom.xml` and add the below dependency
+
[source,xml]
----
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>
----
+
. Enable Eureka by opening `webapi/src/main/java/com/acorn/tutorial/webapi/WebapiApplication.java` and adding @EnableDiscoveryClient`.
+
[source,java]
----
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;

@EnableDiscoveryClient
@EnableFeignClients("com.acorn.tutorial.webapi")
@SpringBootApplication
public class WebapiApplication {

    public static void main(String[] args) {
        SpringApplication.run(WebapiApplication.class, args);
    }

}
----
____

==== Using the OpenFeign client
Let's add code to `WebApiController` that makes use of the OpenFeign client.

[quote]
____
. Open `web/WebApiController.java` and inject the client interfaces
+
[source,java]
----
@RestController
public class WebApiController {

    private final ItemsClient itemsClient;
    private final ReviewsClient reviewsClient;

    @Autowired
    public WebApiController(ItemsClient itemsClient, ReviewsClient reviewsClient) {
        this.itemsClient = itemsClient;
        this.reviewsClient = reviewsClient;
    }

    ...
}
----
+
. The `List<ItemInfoDto> getItems()` does right now return a list containing an empty `ItemInfoDto`. Change this so that underlying services are called via the clients, and then aggregate their responses into the `ItemInfoDto` list.
+
[source,java]
----
@RestController
public class WebApiController {

    ...

    @GetMapping(path = "/webapi/items")
    public List<ItemInfoDto> getItems() {
        LOGGER.info("/webapi/items called");

        List<Item> items = itemsClient.getItems();
        List<Review> reviews = reviewsClient.getReviews("item");

        return items.stream()
                .map(item -> createItemInfoDto(item, reviews))
                .collect(Collectors.toList());
    }

    private ItemInfoDto createItemInfoDto(Item item, List<Review> reviews) {

        List<Review> itemReviews = reviews.stream()
                .filter(review -> item.getId().equals(review.getTypeId()))
                .collect(Collectors.toList());

        return ItemInfoDto.of(item, itemReviews);
    }

    ...
}
----
+
. Method `ItemInfoDto getItem(@PathVariable Long id)` should fetch data for a specific item, please make it so by using this code.
+
[source,java]
----
@RestController
public class WebApiController {

    ...

    @GetMapping(path = "/webapi/items/{id}")
    public ItemInfoDto getItem(@PathVariable Long id) {
        LOGGER.info(String.format("/webapi/items/%d called", id));

        Item item = itemsClient.getItem(id);
        List<Review> reviews = reviewsClient.getReviews("item", id);

        return ItemInfoDto.of(item, reviews);
    }

    ...
}
----
____

The complete `WebApiController` class should now look like this.

[source,java]
----
import java.util.List;
import java.util.stream.Collectors;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class WebApiController {

    private final ItemsClient itemsClient;
    private final ReviewsClient reviewsClient;

    @Autowired
    public WebApiController(ItemsClient itemsClient, ReviewsClient reviewsClient) {
        this.itemsClient = itemsClient;
        this.reviewsClient = reviewsClient;
    }

    @GetMapping(path = "/webapi/items")
    public List<ItemInfoDto> getItems() {

        List<Item> items = itemsClient.getItems();
        List<Review> reviews = reviewsClient.getReviews("item");

        return items.stream()
                .map(item -> createItemInfoDto(item, reviews))
                .collect(Collectors.toList());
    }

    @GetMapping(path = "/webapi/items/{id}")
    public ItemInfoDto getItem(@PathVariable Long id) {

        Item item = itemsClient.getItem(id);
        List<Review> reviews = reviewsClient.getReviews("item", id);

        return ItemInfoDto.of(item, reviews);
    }

    private ItemInfoDto createItemInfoDto(Item item, List<Review> reviews) {

        List<Review> itemReviews = reviews.stream()
                .filter(review -> item.getId().equals(review.getTypeId()))
                .collect(Collectors.toList());

        return ItemInfoDto.of(item, itemReviews);
    }
}
----

We are finally there. Try the application out.

=== Running the application
You should be able to start the server by using one of these two options.

Run from IDE::
IntelliJ: There should be a Run configuration named `WebApiApplication` in the Services pane. Mark it and press the green play-button to start the application. This will build and run the app.

Run from command line:: It is also possible to execute it directly from a command prompt:
+
[source, bash]
----
cd acorn-microservices-tutorial/webapi/target

java -jar webapi-0.0.1-SNAPSHOT.jar
----

[IMPORTANT]
Make sure that the all the other applications are up and running before trying the `webapi`.

Take a look at the logs, the application should start fine.

* Check the health status: http://localhost:8100/actuator/health
* Check Eureka, all relevant apps should be registered: http://localhost:8761
* Fetch all items with corresponding reviews: http://localhost:8100/webapi/items
* Fetch a specific item with corresponding reviews: http://localhost:8100/webapi/items/1

=== Road map revisited
It is now a good time to revisit the road map we charted a while ago. Let's have a look at it and add some comments about our current progress.

|===
|Task|Comment

|Adding Service Discovery Server
|We now utilize an _Eureka_ server that keeps track of services for us. It knows which _host_ and _port_ each service use, information that other Spring Cloud applications can use when needed.

|Enable registering of existing `items-service` and `reviews-service` to registry
|Our example microservices register to the discovery server during startup. During their life time they send heartbeats at regular intervals, letting the discovery server know they are healthy.

|Create the WebApi component `webapi` which discovers the above services using the Service Discovery Server and then calls them
|The BFF WebApi component uses _Spring Cloud OpenFeign_ for calling and aggregating responses from the microservices. OpenFeign clients do not explicitly know where these services are located, instead they fetch this information from the discovery server.
|===

We are making good progress. The communication chain between `webapi` and `items-service`/`reviews-service` are working. The next section will show how to run several instances of the services at once, and also look on what to do when a single service fails.

<<microservices-6.adoc#,Nextup: Client load balancer and fault tolerance>>

