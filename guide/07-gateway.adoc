= Spring Cloud
:toc: left
:imagesdir: images

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

== Gateway
A gateway provides a single entry point for all the microservices running downstream, it's main responsibility is to handle the process of routing and filtering requests. The gateway can either dynamically route the requests to the respective backend application, or use predefined routes (declared in config) to achieve the same thing.

Since a gateway often is the entrance point into the application's microservices eco system, it is common to use it as a place for cross cutting concerns. Examples of this are to let the gateway component handle authentication, or let it gather and manage various metrics.

We will create a gateway server based on https://cloud.spring.io/spring-cloud-netflix/reference/html/#router-and-filter-zuul[Spring Cloud Netflix Zuul], which uses dynamic routing by looking up and creating routes from the `service-discovery-server`. We will also add a simple authentication implemention to it.

[NOTE]
====
Zuul Vs Spring Cloud Gateway

Spring has put the project `spring-cloud-starter-netflix-zuul` (that we user here) in maintenance mode, which means that no new development takes place there (only critical bug fixes). Instead Spring provides a replacement in the form of Spring Cloud Gateway. There is a distinct difference between the technology behind the two projects, Spring Cloud Gateway is built on Spring Framework 5, Project Reactor. This means that it uses non-blocking techniques when handling requests.

Zuul (v1) is a blocking gateway while Spring Cloud Gateway is a non-blocking gateway. In case of non-blocking, the main thread is always available to serve the request and other multiple threads process those requests asynchronously in the background and once the request is completely processed the response is returned. Hence non-blocking model requires a less no of resources to serve the same amount of requests as compared to blocking gateway.


See https://cloud.spring.io/spring-cloud-gateway/reference/html/[Spring Cloud Gateway reference] if you are interested in finding out more.

====

Take a look at the below diagram, where the Gateway has been added. It will indeed be the entrance point for outside clients, and it will route requests downstream to the `webapi`. This means that outsiders have no other ways to access `items-service` and `reviews-service` than via `webapi`.

image::overview-7-gateway.png[]

The gateway will obtain information on how to route to `webapi` from the `service-discovery-server`, in the same manner as we earlier saw the `webapi` access `items-service` and `reviews-service`.

=== Creating the project

[quote]
____
. Go to https://start.spring.io/ (or use IntelliJ `New -> Module... -> Spring Initializr`)
. Enter the following values in fields:
.. `Group:` com.acorn.tutorial
.. `Artifact:` gateway
. Add dependencies (search for them and select):
.. Config Client
.. Eureka Discovery Client
.. Zuul
.. Spring Web
.. Spring Boot Actuator
.. Lombok
. Click `Generate the project`
. If using https://start.spring.io: open the resulting zip and copy the items-service directory to the root of the project (acorn-microservices-tutorial)
____

[TIP]
====
Let's remove some autogenerated files we don't need, delete the following files from project:

- gateway/.mvn (the whole dir)
- gateway/.gitignore
- gateway/HELP.md
- gateway/mvnw
- gateway/mvnw.cmd
====

Next edit the parent pom.xml so that it becomes aware of the child project:
[quote]
____
. Open `acorn-microservices-tutorial/pom.xml`
. Add `gateway` to the modules list in the parent pom:
+
[source,xml]
----
    ...

    <modules>
        <module>config-server</module>
        <module>service-discovery-server</module>
        <module>items-service</module>
        <module>reviews-service</module>
        <module>webapi</module>
        <module>gateway</module>
    </modules>

    ...
----
____

Build the project to verify that all is glued together correctly, and for downloading dependencies:
[source, bash]
----
# Run mvn clean install from the acorn-microservices-tutorial directory
mvn clean install -DskipTests
----

Expected outcome after running the command:

[source]
----
[INFO] Reactor Summary for acorn-microservices-tutorial 0.0.1-SNAPSHOT:
[INFO]
[INFO] util ............................................... SUCCESS [  1.511 s]
[INFO] config-server ...................................... SUCCESS [  5.067 s]
[INFO] service-discovery-server ........................... SUCCESS [  2.776 s]
[INFO] items-service ...................................... SUCCESS [  4.540 s]
[INFO] reviews-service .................................... SUCCESS [  6.234 s]
[INFO] webapi ............................................. SUCCESS [  5.998 s]
[INFO] gateway ............................................ SUCCESS [  4.625 s]
[INFO] acorn-microservices-tutorial ....................... SUCCESS [  0.316 s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
----

=== Configuring the Gateway
As we have done a couple of times earlier by now, we should add the Gateway config to the Config Server.

* The application's general config should be defined in the central `config-server`
* A `bootstrap.yml` file must be created, holding the config for binding to the `config-server`

[quote]
____
. Create the file `config-server/src/main/resource/config/gateway.yml`
. Add config to file:
+
[source,yml]
----
zuul:
  routes:
    webapi:
      sensitiveHeaders: Cookie,Set-Cookie,Authorization
      stripPrefix: false

eureka:
  client:
    register-with-eureka: true
    service-url:
      default-zone: http://localhost:8761/eureka

management:
  endpoints:
    web:
      exposure:
        include: "*"

logging:
  level:
    org.springframework.security.web: info
----
+
. Rebuild the `config-server`
+
[source,bash]
----
cd config-server
mvn clean install -DskipTests
----
+
. Restart `config-server`
. Verify that all looks good by accessing http://localhost:7777/gateway/default
____

Next create the `bootstrap.yml` and add config for binding to `config-server`
[quote]
____
. Delete `gateway/src/main/resources/application.properties`
. Create the file `gateway/src/main/resource/bootstrap.yml`
. Add config to file:
+
[source,yml]
----
spring:
  application:
    name: gateway
  cloud:
    config:
      fail-fast: true
      uri: http://localhost:7777

server:
  port: 20202
----
____

=== Running the application
You should be able to start the server by using one of these two options.

Run from IDE::
IntelliJ: There should be a Run configuration named `GatewayApplication` in the Services pane. Mark it and press the green play-button to start the application. This will build and run the app.

Run from command line:: It is also possible to execute it directly from a command prompt:
+
[source, bash]
----
cd acorn-microservices-tutorial/gateway/target

java -jar gateway-0.0.1-SNAPSHOT.jar
----

Take a look at the logs, the application should start fine.

* Check the health status: http://localhost:20202/actuator/health
* Check Eureka, the `gateway` should be registered: http://localhost:8761
* Access http://localhost:20202/webapi/items

[WARNING]
====
Oh no, it doesn't work! You get the message _There was an unexpected error (type=Not Found, status=404)_.

Well that is because you forgot to enable the _Zuul proxy_ (schmuck) so no routing is going on. Open `gateway/src/main/java/com/acorn/tutorial/gateway/GatewayApplication.java` and add `@EnableZuulProxy`:

[source,java]
----
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;

@EnableZuulProxy
@SpringBootApplication
public class GatewayApplication {

	public static void main(String[] args) {
		SpringApplication.run(GatewayApplication.class, args);
	}
}
----
====

Restart `gateway` and try again.

Hooray, you should now have been routed to the `webapi` properly.

Now to the next part, find out what happens if you access one of the services behind `webapi` directly via the `gateway`:

* http://localhost:20202/items-service/items

What happened? Did you get a response with items?

As it is setup right now, you should actually get a response from `items-service` looking like this:

[source,json]
----
[
  {
    "id": 1,
    "name": "Spoon",
    "port": 8081
  },
  {
    "id": 2,
    "name": "Fork",
    "port": 8081
  },
  {
    "id": 3,
    "name": "Knife",
    "port": 8081
  }
]
----

In fact, this is true for all the other services as well (you can see them listed at http://localhost:20202/actuator/routes). It is hence possible to also access

* http://localhost:20202/reviews-service/reviews

* http://localhost:20202/service-discovery-server

* (but not config-server, because it has not been registered in `service-discovery-server`)

As stated in the beginning of this chapter, we do not want this behavior. Clients should only be able to access the system via the `gateway` which routes to the `webapi` only. So how can we tell the `gateway` to allow certain routes, but not others?

One way to do it is to use a Zuul filter.

=== Adding a Zuul filter

At the center of Zuul is a series of Filters that are capable of performing a range of actions during the routing of HTTP requests and responses.

The following are the key characteristics of a Zuul Filter:

* Type: most often defines the stage during the routing flow when the Filter will be applied (although it can be any custom string)

* Execution Order: applied within the Type, defines the order of execution across multiple Filters

* Criteria: the conditions required in order for the Filter to be executed

* Action: the action to be executed if the Criteria is met

Zuul provides a framework to dynamically read, compile, and run these Filters. Filters do not communicate with each other directly - instead they share state through a RequestContext which is unique to each request.

A visit to http://localhost:20202/actuator/filters shows the default Zuul filters that always are in effect. It is also possible to add custom filters to the filter chain, something we will do right now.

Let's add a filter with the following abilities:

 * Determine if the current request tries to access any forbidden services directly

 * If so, halt the process and send back 404 Not Found.

[quote]
____
. Start by adding a new class named ForbiddenPathFilter, `gateway/src/main/java/com/acorn/tutorial/gateway/routing/ForbiddenPathFilter.java`

. Add this code:
+
[source,java]
----
import static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.*;
import java.util.Collections;
import java.util.List;
import org.springframework.stereotype.Component;
import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;

@Component
public class ForbiddenPathFilter extends ZuulFilter {

    @Override
    public String filterType() {
        /*
         * The filter type decides when in the routing cycle the filter triggers.
         * - PRE_TYPE: filters are executed before the request is routed
         * - ROUTE_TYPE: route filters can handle the actual routing of the request
         * - POST_TYPE: filters are executed after the request has been routed
         * - ERROR_TYPE: filters execute if an error occurs in the course of handling the request
         */
        return PRE_TYPE;
    }

    @Override
    public int filterOrder() {
        // filter order decides where in the chain of Spring's predefined Zuul filters this filter should be placed.
        // You can access http://localhost:20202/actuator/filters to see the filters in effect,
        // We want to access the serviceId, which is populated by the inbuilt pre-decoration filter, so this filter must execute after that
        return PRE_DECORATION_FILTER_ORDER + 1;
    }

    @Override
    public boolean shouldFilter() {
        // This decides if the filter should be executed in the current context
        String serviceId = (String) RequestContext.getCurrentContext().get(SERVICE_ID_KEY);
        return !isAllowedService(serviceId);
    }

    @Override
    public Object run() {

        // This method is only executed if shouldFilter() returns true

        // Halt the process and return 404
        RequestContext requestContext = RequestContext.getCurrentContext();
        requestContext.unset();
        requestContext.getResponse().setContentType("text/html");
        requestContext.setResponseStatusCode(404);
        requestContext.setSendZuulResponse(false);

        return null;
    }

    private boolean isAllowedService(String serviceId) {
        List<String> allowedServices = Collections.singletonList("webapi");
        return serviceId != null && allowedServices.contains(serviceId);
    }
}
----
+
. Restart the application and check if you can see the filter in http://localhost:20202/actuator/filters

. Access http://localhost:20202/items-service/items again
.. It should now return 404
____

This was just one example of how to add a filter for modifying the routing behavior. Filters are generally used for the majority of proxy/gateway work, for example: dynamic routing, rate limiting (i.e. slowing eager client requests down a bit), DDoS protection, metrics, to name a few.

Below is a filter of type "post", which logs the content of response bodies. Add it if you like, or move on to the next section.

[source,java]
----
import static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.POST_TYPE;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import com.google.common.io.CharStreams;
import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;

/**
* Filter that writes the response body to console log
*/
@Component
public class ResponseBodyFilter extends ZuulFilter {

    private static final Logger LOGGER = LoggerFactory.getLogger(ResponseBodyFilter.class);

    @Override
    public String filterType() {
        return POST_TYPE;
    }

    @Override
    public int filterOrder() {
        return 2;
    }

    @Override
    public boolean shouldFilter() {
        return true;
    }

    @Override
    public Object run() {

        RequestContext requestContext = RequestContext.getCurrentContext();
        try (final InputStream responseDataStream = requestContext.getResponseDataStream()) {
            final String responseData = CharStreams.toString(new InputStreamReader(responseDataStream, "UTF-8"));

            String line = String.format("Response body: %s", responseData);
            LOGGER.info(line);

            requestContext.setResponseBody(responseData);
        } catch (IOException e) {
            LOGGER.error("Error reading response body", e);
        }

        return null;
    }
}
----

== Adding authentication

A gateway component typically handles cross cutting concerns like authentication. The field comprising authentication methods are quite large, there are several authentication schemes and patterns that can be used, each one more complex than the other. Typically you hear of https://connect2id.com/products/ldapauth/auth-explained[LDAP], https://en.wikipedia.org/wiki/SAML_2.0[SAML], https://oauth.net/2/[OAuth 2.0], https://openid.net/connect/[OpenID Connect] (and more), which all have this in common: They are usually complicated beyond belief to implement, afterwards leaving a stale taste in your mouth and additional grey hair in various places.

We will not implement such here. Instead we will go for a simple basic authentication solution, which should of course not be considered in production worthy systems.

=== Spring Security
The goal of this section is to get a brief glimpse of the topic of security. Below we will setup an authentication solution using https://docs.spring.io/spring-security/site/docs/5.2.1.BUILD-SNAPSHOT/reference/htmlsingle/[Spring Security].

Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications. The authentication process is basically a chain of pre-built filters and beans (code components) that operates on the incoming request. These filters can be overridden or customized as you see fit.

What we want to do is:

* Setup a set of trusted users and passwords (in a static file)
* Enable Spring Security and configure it for handling basic auth.
* Create an AuthenticationProvider that we add to the configuration

[quote]
____
. Add a new file `gateway/src/main/resources/users.yml` with this content
+
[source,yml]
----
localauth:
    users:
      - userId: "admin"
        password: "{bcrypt}$2a$10$LSFBr7wQG1/AIkEdTzXOjOhK5lINUk4nQYfGKCjGvpe6m3XXUVE7y"
        roles:
          - administrator

      - userId: "frank"
        password: "{bcrypt}$2a$10$LSFBr7wQG1/AIkEdTzXOjOhK5lINUk4nQYfGKCjGvpe6m3XXUVE7y"
        roles:
          - employee
----
+
Note that the encrypted password in clear text is _abc_.

. Create package `gateway/src/main/java/com/acorn/tutorial/gateway/authentication/localauth`
. Add class `LocalAuth.java` for holding user data
+
[source,java]
----
import lombok.Value;

import java.util.List;

/**
 * Represents the entry for a user in the local user directory.
 */
@Data
public class LocalUser {
    private String userId;
    private String password;
    private List<String> roles;
}
----
+
. Add class `LocalAuthProperties` (this class loads the users.yml file so that we can handle the content programmatically).
+
[source,java]
----
import lombok.Data;
import org.springframework.beans.factory.config.YamlPropertiesFactoryBean;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Profile;
import org.springframework.context.annotation.PropertySource;
import org.springframework.core.env.PropertiesPropertySource;
import org.springframework.core.io.support.EncodedResource;
import org.springframework.core.io.support.PropertySourceFactory;
import org.springframework.lang.Nullable;
import org.springframework.stereotype.Component;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.List;
import java.util.Properties;

/**
 * Properties class for local authentication config attributes.
 * <p>
 * Local users are defined in a file "users.yml" located on classpath
 */
@Profile("localauth")
@Component
@PropertySource(value = "classpath:users.yml", ignoreResourceNotFound = true, factory = LocalAuthProperties.YamlPropertySourceFactory.class)
@ConfigurationProperties(prefix = "localauth")
@Data
public class LocalAuthProperties {
    /**
     * The locally defined users.
     */
    private List<LocalUser> users;

    static class YamlPropertySourceFactory implements PropertySourceFactory {

        @Override
        public org.springframework.core.env.PropertySource<?> createPropertySource(@Nullable String name, EncodedResource resource) throws IOException {
            Properties propertiesFromYaml = loadYamlIntoProperties(resource);
            String sourceName = name != null ? name : resource.getResource().getFilename();
            return new PropertiesPropertySource(sourceName, propertiesFromYaml);
        }

        private Properties loadYamlIntoProperties(EncodedResource resource) throws FileNotFoundException {
            try {
                YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean();
                factory.setResources(resource.getResource());
                factory.afterPropertiesSet();
                return factory.getObject();

            } catch (IllegalStateException e) {
                // for ignoreResourceNotFound
                Throwable cause = e.getCause();
                if (cause instanceof FileNotFoundException) {
                    throw (FileNotFoundException) e.getCause();
                }

                throw e;
            }
        }
    }
}
----
+
. Open `gateway/pom.xml` and dependency to Spring Security
+
[source,xml]
----
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
----
+
. Add our custom authentication provider, `gateway/src/main/java/com/acorn/tutorial/gateway/authentication/localauth/LocalAuthProvider.java`
+
[source,java]
----
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Profile;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationToken;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Component
@Profile("localauth")
public class LocalAuthProvider implements AuthenticationProvider {

    private static final Logger LOGGER = LoggerFactory.getLogger(LocalAuthProvider.class);
    private static final Object CREDENTIALS_FOR_AUTHENTICATED_TOKEN = "[dummy credentials]";

    private final LocalAuthProperties properties;
    private final PasswordEncoder passwordEncoder;

    @Autowired
    public LocalAuthProvider(LocalAuthProperties properties, PasswordEncoder passwordEncoder) {
        this.properties = properties;
        this.passwordEncoder = passwordEncoder;

        if (properties.getUsers() == null) {
            LOGGER.warn("No local users defined. Are we missing a 'users.yml' file?");
        } else {
            LOGGER.info("Setting up a local users directory with users found in users.yml:");
            properties.getUsers()
                    .forEach(localUser -> LOGGER.info("-> UserId: {}, roles: {}", localUser.getUserId(), localUser.getRoles()));
        }
    }

    @Override
    public Authentication authenticate(Authentication authentication) {
        final String name = authentication.getName();
        final String rawPassword = authentication.getCredentials().toString();

        final Optional<LocalUser> localUser = getLocalUser(name, rawPassword);

        return localUser
                .map(LocalAuthProvider::createPreAuthenticatedAuthenticationToken)
                .orElseThrow(() -> new BadCredentialsException("Incorrect user name or password"));
    }

    private Optional<LocalUser> getLocalUser(String name, String rawPassword) {
        List<LocalUser> users = properties.getUsers();
        if (users == null) {
            return Optional.empty();
        }

        return users.stream()
                .filter(user -> name.equals(user.getUserId()) && passwordEncoder.matches(rawPassword, user.getPassword()))
                .findFirst();
    }


    @Override
    public boolean supports(Class<?> authentication) {
        return UsernamePasswordAuthenticationToken.class.equals(authentication);
    }

    private static PreAuthenticatedAuthenticationToken createPreAuthenticatedAuthenticationToken(LocalUser localUser) {
        final PreAuthenticatedAuthenticationToken token = new PreAuthenticatedAuthenticationToken(localUser.getUserId(), CREDENTIALS_FOR_AUTHENTICATED_TOKEN, createGrantedAuthorities(localUser.getRoles()));
        token.setDetails(localUser);
        return token;
    }

    private static Collection<? extends GrantedAuthority> createGrantedAuthorities(List<String> roles) {
        return roles.stream()
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
    }
}
----
+
. Create the security configuration, add file `gateway/src/main/java/com/acorn/tutorial/gateway/authentication/localauth/LocalAuthSecurityConfiguration.java`
+
[source,java]
----
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

/**
 * Authenticates using a local user directory (from config files).
 */
@Profile("localauth")
@Configuration
@EnableWebSecurity(debug = false)
public class LocalAuthSecurityConfiguration extends WebSecurityConfigurerAdapter {

    private final LocalAuthProvider authProvider;

    @Autowired
    public LocalAuthSecurityConfiguration(LocalAuthProvider authProvider) {
        this.authProvider = authProvider;
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) {
        // Instruct Spring Security to use our authentication provider
        auth.authenticationProvider(authProvider);
    }


    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable();

        http
                .authorizeRequests() // Instruct Spring Security to act on incoming requests
                .antMatchers("/actuator/**").permitAll() // This excludes /actuator from the security check, i.e. we don't need to be authenticated here
                .anyRequest().fullyAuthenticated() // instruct spring security that we must be authenticated to allow request
                .and()
                    .httpBasic(); // ... using http basic
    }
}
----
+
. and finally add `LocalAuthPasswordEncoderConfiguration.java` that knows how encode the passwords
+
[source,java]
----
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.crypto.password.PasswordEncoder;

/**
 * Configures the password encoder for the local user authentication.
 * <p>
 * Generate the password with:
 *
 * <pre>
 *   python -c 'import bcrypt; print(bcrypt.hashpw("password", bcrypt.gensalt(rounds=10)))' | sed 's/$2b/$2a/'
 * </pre>
 *
 * or
 *
 * <pre>
 *   htpasswd -bnBC 10 ""  password | tr -d ':\n' | sed 's/$2y/$2a/'
 * </pre>
 *
 * ... and prefix it with "{bcrypt}". For example:
 *
 * <pre>
 *     localauth:
 *       users:
 *         - userId: "admin"
 *           password: "{bcrypt}$2a$10$LSFBr7wQG1/AIkEdTzXOjOhK5lINUk4nQYfGKCjGvpe6m3XXUVE7y"
 *           roles:
 *             - administrator
 * </pre>
 *
 * The 'sed' operation is required due to a bug in Spring Security.
 * <a href="https://github.com/spring-projects/spring-security/issues/3320">A fix seems to be scheduled for release 5.2.0.</a>
 */
@Profile("localauth")
@Configuration
public class LocalAuthPasswordEncoderConfiguration {
    @Bean
    public PasswordEncoder passwordEncoder() {
        return PasswordEncoderFactories.createDelegatingPasswordEncoder();
    }
}
----
____

There. Sorry for bashing this through like a steam train, but by now all code should be in place.

Note the annotation `@Profile("localauth")`. This means that the security is only enabled if we start the `gateway` with this profile active. Do this as follows:

Run from IDE::
IntelliJ: Open the Run Configuration for `GatewayApplication`, add  `spring.profiles.active=localauth` in _Override parameters_ section:
+
image::gateway-localauth-run-configuration.png[]
+
Then start the `gateway` as normal

Run from command line:: It is also possible to execute it directly from a command prompt:
+
[source, bash]
----
cd acorn-microservices-tutorial/gateway/target

java -jar gateway-0.0.1-SNAPSHOT.jar --spring.profiles.active=localauth
----

When all is up and running, access the application again at http://localhost:20202/webapi/items. Use _frank_ och _abc_ to get pass.

Alternatively, if you have `curl` on your system, you can open a command prompt and run
[source,bash]
----
# This should yield a 401
curl -X GET http://localhost:20202/webapi/items

# This should be fine
curl -X GET http://localhost:20202/webapi/items --user frank:abc
----

And on this bombshell we are done with the `gateway`. Take a break, and perhaps a beer if it's beer o´clock. Next up is the final topic of Distributed tracing.

<<08-distributed-tracing.adoc#,Nextup: Distributed tracing>>

